#!/usr/bin/env python3
"""
Bot Telegram interactif ‚Äî Seko-VPN
Commandes : /status /containers /disk /logs /restart /uptime /help
"""
import asyncio
import logging
import os
import subprocess
from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes

# --- Configuration ---
TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
ALLOWED_IDS = [int(x.strip()) for x in os.environ.get("ALLOWED_CHAT_IDS", "").split(",") if x.strip()]
SERVER = os.environ.get("SERVER_NAME", "seko-vpn")

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# Stockage des confirmations de restart en attente
pending_restarts = {}


def authorized(func):
    """D√©corateur pour v√©rifier les chat IDs autoris√©s."""
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_chat.id not in ALLOWED_IDS:
            await update.message.reply_text("‚õî Non autoris√©.")
            return
        return await func(update, context)
    return wrapper


def run_cmd(cmd: str, timeout: int = 30) -> str:
    """Ex√©cute une commande et retourne la sortie."""
    try:
        result = subprocess.run(
            cmd, shell=True, capture_output=True, text=True, timeout=timeout
        )
        return result.stdout.strip() or result.stderr.strip() or "(pas de sortie)"
    except subprocess.TimeoutExpired:
        return "‚è∞ Timeout"
    except Exception as e:
        return f"‚ùå Erreur: {e}"


@authorized
async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Affiche le r√©sum√© Monit."""
    output = run_cmd("monit summary 2>/dev/null || echo 'Monit indisponible'")
    await update.message.reply_text(f"[{SERVER}] üìä Monit Summary\n{'‚îÄ' * 25}\n{output}")


@authorized
async def cmd_containers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liste les conteneurs Docker."""
    output = run_cmd('docker ps --format "table {{ '{{' }}.Names{{ '}}' }}\t{{ '{{' }}.Status{{ '}}' }}\t{{ '{{' }}.Ports{{ '}}' }}"')
    await update.message.reply_text(f"[{SERVER}] üê≥ Conteneurs\n{'‚îÄ' * 25}\n{output}")


@authorized
async def cmd_disk(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Affiche l'utilisation disque."""
    output = run_cmd("df -h --output=target,pcent,size,avail | head -10")
    await update.message.reply_text(f"[{SERVER}] üíæ Disque\n{'‚îÄ' * 25}\n{output}")


@authorized
async def cmd_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Affiche les 20 derni√®res lignes de logs d'un service."""
    if not context.args:
        await update.message.reply_text(f"[{SERVER}] Usage: /logs <service>\nExemple: /logs headscale")
        return
    service = context.args[0]
    # Essayer Docker d'abord, puis journalctl
    output = run_cmd(f"docker logs --tail 20 {service} 2>/dev/null")
    if "No such container" in output or "Error" in output:
        output = run_cmd(f"journalctl -u {service} -n 20 --no-pager 2>/dev/null")
    # Tronquer si trop long
    if len(output) > 3500:
        output = output[:3500] + "\n... (tronqu√©)"
    await update.message.reply_text(f"[{SERVER}] üìã Logs {service}\n{'‚îÄ' * 25}\n{output}")


@authorized
async def cmd_restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Demande confirmation avant de red√©marrer un service."""
    if not context.args:
        await update.message.reply_text(f"[{SERVER}] Usage: /restart <service>")
        return
    service = context.args[0]
    chat_id = update.effective_chat.id
    pending_restarts[chat_id] = service
    await update.message.reply_text(
        f"[{SERVER}] ‚ö†Ô∏è Confirmer le red√©marrage de '{service}' ?\n"
        f"Envoyez /restart_confirm {service} pour confirmer."
    )


@authorized
async def cmd_restart_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Confirme et ex√©cute le red√©marrage."""
    chat_id = update.effective_chat.id
    if not context.args:
        await update.message.reply_text(f"[{SERVER}] Usage: /restart_confirm <service>")
        return
    service = context.args[0]
    if chat_id not in pending_restarts or pending_restarts[chat_id] != service:
        await update.message.reply_text(f"[{SERVER}] ‚ùå Pas de red√©marrage en attente pour '{service}'.")
        return
    del pending_restarts[chat_id]
    await update.message.reply_text(f"[{SERVER}] üîÑ Red√©marrage de '{service}'...")
    # Essayer Docker d'abord, puis systemctl
    output = run_cmd(f"docker restart {service} 2>/dev/null")
    if "No such container" in output or "Error" in output:
        output = run_cmd(f"systemctl restart {service} 2>/dev/null && echo 'OK' || echo 'ERREUR'")
    await update.message.reply_text(f"[{SERVER}] ‚úÖ R√©sultat: {output}")


@authorized
async def cmd_uptime(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Affiche l'uptime du serveur."""
    output = run_cmd("uptime -p")
    load = run_cmd("cat /proc/loadavg")
    await update.message.reply_text(f"[{SERVER}] ‚è± Uptime\n{'‚îÄ' * 25}\n{output}\nLoad: {load}")


@authorized
async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liste des commandes disponibles."""
    help_text = f"""[{SERVER}] ü§ñ Commandes disponibles
{'‚îÄ' * 25}
/status ‚Äî R√©sum√© Monit (√©tat des services)
/containers ‚Äî Liste des conteneurs Docker
/disk ‚Äî Utilisation disque
/logs <service> ‚Äî 20 derni√®res lignes de logs
/restart <service> ‚Äî Red√©marrer (avec confirmation)
/uptime ‚Äî Uptime serveur + charge
/help ‚Äî Cette aide"""
    await update.message.reply_text(help_text)


def main():
    """Point d'entr√©e du bot."""
    if not TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN non d√©fini !")
        return
    if not ALLOWED_IDS:
        logger.error("ALLOWED_CHAT_IDS non d√©fini !")
        return

    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("status", cmd_status))
    app.add_handler(CommandHandler("containers", cmd_containers))
    app.add_handler(CommandHandler("disk", cmd_disk))
    app.add_handler(CommandHandler("logs", cmd_logs))
    app.add_handler(CommandHandler("restart", cmd_restart))
    app.add_handler(CommandHandler("restart_confirm", cmd_restart_confirm))
    app.add_handler(CommandHandler("uptime", cmd_uptime))
    app.add_handler(CommandHandler("help", cmd_help))

    logger.info(f"Bot d√©marr√© pour le serveur [{SERVER}]")
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
