#!/usr/bin/env python3
"""
Bot Telegram interactif — Seko-VPN V3.2
25 commandes : menu, status, services, containers, disk, memory, cpu, network,
logs, restart, uptime, updates, backup, ssl, vpn, security, mute, unmute, ack,
monitors, ukpause, ukresume, maintenance, quick, help
"""
import json
import logging
import os
import re
import subprocess
import time
from datetime import datetime, timezone
from html import escape as html_escape
from pathlib import Path

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
)

# --- Configuration ---
TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
ALLOWED_IDS = [
    int(x.strip())
    for x in os.environ.get("ALLOWED_CHAT_IDS", "").split(",")
    if x.strip()
]
SERVER = os.environ.get("SERVER_NAME", "seko-vpn")
DOMAINS = {
    "headscale": os.environ.get("DOMAIN_HEADSCALE", ""),
    "headplane": os.environ.get("DOMAIN_HEADPLANE", ""),
    "vaultwarden": os.environ.get("DOMAIN_VAULTWARDEN", ""),
    "portainer": os.environ.get("DOMAIN_PORTAINER", ""),
    "zerobyte": os.environ.get("DOMAIN_ZEROBYTE", ""),
    "uptime-kuma": os.environ.get("DOMAIN_UPTIME_KUMA", ""),
}
SSH_PORT = os.environ.get("SSH_PORT", "804")

# Uptime Kuma API
UPTIME_KUMA_URL = "http://127.0.0.1:3001"
UPTIME_KUMA_USER = os.environ.get("UPTIME_KUMA_USERNAME", "admin")
UPTIME_KUMA_PASS = os.environ.get("UPTIME_KUMA_PASSWORD", "")

MUTE_FILE = Path("/tmp/seko-mute.json")
DOCKER_SERVICES = [
    "headscale", "headplane", "vaultwarden", "portainer",
    "zerobyte", "caddy", "uptime-kuma",
]
SYSTEMD_SERVICES = ["monit", "telegram-bot", "docker", "grafana-alloy"]

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)


# ─────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────

def now_str():
    """Timestamp lisible."""
    return datetime.now(tz=timezone.utc).strftime("%H:%M:%S UTC")


def html_header(title, emoji=""):
    """En-tete HTML avec serveur et timestamp."""
    return (
        f"{emoji} <b>[{html_escape(SERVER)}] {html_escape(title)}</b>\n"
        f"<i>{now_str()}</i>\n{'─' * 28}\n"
    )


def progress_bar(percent, length=10):
    """Barre de progression visuelle."""
    percent = max(0, min(100, percent))
    filled = round(length * percent / 100)
    bar = "▓" * filled + "░" * (length - filled)
    return f"{bar} {percent:.0f}%"


def truncate(text, limit=3800):
    """Tronque un message pour Telegram (4096 max)."""
    if len(text) <= limit:
        return text
    return text[:limit] + "\n\n<i>... (tronque)</i>"


def run_cmd(cmd, timeout=30):
    """Execute une commande shell et retourne la sortie."""
    try:
        result = subprocess.run(
            cmd, shell=True, capture_output=True, text=True, timeout=timeout,
        )
        return result.stdout.strip() or result.stderr.strip() or "(pas de sortie)"
    except subprocess.TimeoutExpired:
        return "Timeout"
    except Exception as exc:
        return f"Erreur: {exc}"


def is_muted():
    """Verifie si les notifications sont silencees."""
    if not MUTE_FILE.exists():
        return False, ""
    try:
        data = json.loads(MUTE_FILE.read_text())
        until = data.get("until", 0)
        if time.time() < until:
            remaining = int((until - time.time()) / 60)
            return True, f"{remaining} min restantes"
        MUTE_FILE.unlink(missing_ok=True)
    except (json.JSONDecodeError, OSError):
        MUTE_FILE.unlink(missing_ok=True)
    return False, ""


def set_mute(minutes):
    """Active le mode silencieux."""
    data = {"until": time.time() + minutes * 60, "since": now_str()}
    MUTE_FILE.write_text(json.dumps(data))


def clear_mute():
    """Desactive le mode silencieux."""
    MUTE_FILE.unlink(missing_ok=True)


def get_uptime_kuma_api():
    """Connecte et login a Uptime Kuma. Retourne (api, error_msg)."""
    try:
        from uptime_kuma_api import UptimeKumaApi
        api = UptimeKumaApi(UPTIME_KUMA_URL)
        api.login(UPTIME_KUMA_USER, UPTIME_KUMA_PASS)
        return api, None
    except Exception as exc:
        return None, str(exc)


# ─────────────────────────────────────────────
# Decorateurs d'autorisation
# ─────────────────────────────────────────────

def authorized(func):
    """Decorateur : verifie les chat IDs autorises (commandes)."""
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_chat.id not in ALLOWED_IDS:
            await update.message.reply_text("Non autorise.")
            return
        return await func(update, context)
    return wrapper


def authorized_callback(func):
    """Decorateur : verifie les chat IDs autorises (callbacks)."""
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        if query.message.chat.id not in ALLOWED_IDS:
            await query.answer("Non autorise.")
            return
        return await func(update, context)
    return wrapper


# ─────────────────────────────────────────────
# Menu principal
# ─────────────────────────────────────────────

MENU_KEYBOARD = InlineKeyboardMarkup([
    [
        InlineKeyboardButton("\U0001f4ca Status", callback_data="menu_status"),
        InlineKeyboardButton("\U0001f433 Services", callback_data="menu_services"),
        InlineKeyboardButton("\U0001f4e6 Containers", callback_data="menu_containers"),
    ],
    [
        InlineKeyboardButton("\U0001f4be Disk", callback_data="menu_disk"),
        InlineKeyboardButton("\U0001f9e0 Memory", callback_data="menu_memory"),
        InlineKeyboardButton("\U00002699\U0000fe0f CPU", callback_data="menu_cpu"),
    ],
    [
        InlineKeyboardButton("\U0001f512 SSL", callback_data="menu_ssl"),
        InlineKeyboardButton("\U0001f510 VPN", callback_data="menu_vpn"),
        InlineKeyboardButton("\U0001f6e1 Security", callback_data="menu_security"),
    ],
    [
        InlineKeyboardButton("\U0001f4e1 Monitors", callback_data="menu_monitors"),
        InlineKeyboardButton("\U0001f507 Mute", callback_data="menu_mute"),
        InlineKeyboardButton("\U00002753 Help", callback_data="menu_help"),
    ],
])


@authorized
async def cmd_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Menu principal avec grille de boutons inline."""
    msg = html_header("Menu principal", "\U00002261")
    msg += "<i>Cliquez sur une action :</i>"
    await update.message.reply_text(
        msg, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD,
    )


# ─────────────────────────────────────────────
# Commandes informationnelles
# ─────────────────────────────────────────────

@authorized
async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Resume Monit avec formatage HTML."""
    raw = run_cmd("monit summary 2>/dev/null || echo 'Monit indisponible'")
    lines = raw.split("\n")
    msg = html_header("Monit Status", "\U0001f4ca")
    for line in lines:
        if not line.strip():
            continue
        if "OK" in line or "Running" in line or "Accessible" in line:
            msg += f"\U00002705 <code>{html_escape(line.strip())}</code>\n"
        elif "FAILED" in line or "Does not exist" in line:
            msg += f"\U0000274c <code>{html_escape(line.strip())}</code>\n"
        elif "Initializing" in line or "Not monitored" in line:
            msg += f"\U000023f3 <code>{html_escape(line.strip())}</code>\n"
        else:
            msg += f"  <code>{html_escape(line.strip())}</code>\n"
    muted, mute_info = is_muted()
    if muted:
        msg += f"\n\U0001f507 <b>Notifications silencees</b> ({mute_info})"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_services(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liste services avec inline keyboard drill-down."""
    buttons = []
    for svc in DOCKER_SERVICES:
        buttons.append([InlineKeyboardButton(
            f"\U0001f433 {svc}", callback_data=f"svc_docker_{svc}",
        )])
    for svc in SYSTEMD_SERVICES:
        buttons.append([InlineKeyboardButton(
            f"\U00002699\U0000fe0f {svc}", callback_data=f"svc_systemd_{svc}",
        )])
    msg = html_header("Services", "\U0001f5a5")
    msg += "<i>Cliquez sur un service pour voir les details</i>"
    await update.message.reply_text(
        msg, parse_mode=ParseMode.HTML,
        reply_markup=InlineKeyboardMarkup(buttons),
    )


@authorized
async def cmd_containers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liste les conteneurs Docker formates."""
    raw = run_cmd(
        'docker ps -a --format "'
        "{{ '{{' }}.Names{{ '}}' }}|"
        "{{ '{{' }}.Status{{ '}}' }}|"
        "{{ '{{' }}.Image{{ '}}' }}"
        '"'
    )
    msg = html_header("Conteneurs Docker", "\U0001f433")
    for line in raw.split("\n"):
        if not line.strip() or "|" not in line:
            continue
        parts = line.split("|", 2)
        if len(parts) < 3:
            continue
        name, status, image = parts[0].strip(), parts[1].strip(), parts[2].strip()
        icon = "\U00002705" if "Up" in status else "\U0000274c"
        msg += f"{icon} <b>{html_escape(name)}</b>\n"
        msg += f"   Status: <code>{html_escape(status)}</code>\n"
        msg += f"   Image: <code>{html_escape(image)}</code>\n\n"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_disk(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Usage disque avec barres de progression."""
    raw = run_cmd("df -h --output=target,pcent,size,avail -x tmpfs -x devtmpfs 2>/dev/null")
    msg = html_header("Disque", "\U0001f4be")
    for line in raw.split("\n")[1:]:
        parts = line.split()
        if len(parts) < 4:
            continue
        mount, pct_str, size, avail = parts[0], parts[1], parts[2], parts[3]
        try:
            pct = int(pct_str.replace("%", ""))
        except ValueError:
            continue
        warn = " \U000026a0" if pct > 80 else ""
        msg += (
            f"<b>{html_escape(mount)}</b>{warn}\n"
            f"  {progress_bar(pct)} ({html_escape(size)} total, "
            f"{html_escape(avail)} libre)\n\n"
        )
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_memory(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """RAM usage avec barre de progression."""
    raw = run_cmd("free -m | grep Mem")
    msg = html_header("Memoire", "\U0001f9e0")
    parts = raw.split()
    if len(parts) >= 3:
        try:
            total = int(parts[1])
            used = int(parts[2])
            pct = (used / total * 100) if total > 0 else 0
            free_mb = total - used
            msg += "<b>RAM</b>\n"
            msg += f"  {progress_bar(pct)}\n"
            msg += f"  <code>{used} Mo / {total} Mo</code> ({free_mb} Mo libre)\n\n"
        except (ValueError, IndexError):
            msg += f"<pre>{html_escape(raw)}</pre>\n"
    swap_raw = run_cmd("free -m | grep Swap")
    swap_parts = swap_raw.split()
    if len(swap_parts) >= 3:
        try:
            s_total = int(swap_parts[1])
            s_used = int(swap_parts[2])
            if s_total > 0:
                s_pct = s_used / s_total * 100
                msg += "<b>Swap</b>\n"
                msg += f"  {progress_bar(s_pct)}\n"
                msg += f"  <code>{s_used} Mo / {s_total} Mo</code>\n"
        except (ValueError, IndexError):
            pass
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_cpu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Load average + top 5 processus."""
    loadavg = run_cmd("cat /proc/loadavg")
    nproc = run_cmd("nproc")
    top5 = run_cmd("ps aux --sort=-%cpu --no-headers | head -5")
    msg = html_header("CPU", "\U00002699\U0000fe0f")
    parts = loadavg.split()
    if len(parts) >= 3:
        msg += f"<b>Load Average</b>: <code>{parts[0]} {parts[1]} {parts[2]}</code>\n"
        msg += f"<b>Coeurs</b>: <code>{html_escape(nproc.strip())}</code>\n\n"
    msg += "<b>Top 5 processus (CPU)</b>\n<pre>"
    for line in top5.split("\n")[:5]:
        cols = line.split(None, 10)
        if len(cols) >= 11:
            msg += f"{cols[2]:>5}%  {html_escape(cols[10][:40])}\n"
    msg += "</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_network(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Connexions actives et ports en ecoute."""
    listen = run_cmd("ss -tlnp 2>/dev/null | head -20")
    conns = run_cmd("ss -s 2>/dev/null")
    msg = html_header("Reseau", "\U0001f310")
    msg += "<b>Ports en ecoute</b>\n<pre>"
    msg += html_escape(listen) + "</pre>\n\n"
    msg += "<b>Resume connexions</b>\n<pre>"
    msg += html_escape(conns) + "</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_uptime(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Uptime, load, kernel."""
    up = run_cmd("uptime -p")
    since = run_cmd("uptime -s")
    kernel = run_cmd("uname -r")
    load = run_cmd("cat /proc/loadavg")
    msg = html_header("Uptime", "\U000023f1")
    msg += f"<b>Uptime</b>: <code>{html_escape(up)}</code>\n"
    msg += f"<b>Depuis</b>: <code>{html_escape(since)}</code>\n"
    msg += f"<b>Kernel</b>: <code>{html_escape(kernel)}</code>\n"
    msg += f"<b>Load</b>: <code>{html_escape(load)}</code>\n"
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML)


# ─────────────────────────────────────────────
# Commandes actions
# ─────────────────────────────────────────────

@authorized
async def cmd_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """20 dernieres lignes de logs d'un service."""
    if not context.args:
        buttons = []
        for svc in DOCKER_SERVICES:
            buttons.append([InlineKeyboardButton(
                f"\U0001f433 {svc}", callback_data=f"logs_{svc}",
            )])
        msg = html_header("Logs", "\U0001f4cb")
        msg += "<i>Choisissez un service :</i>"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML,
            reply_markup=InlineKeyboardMarkup(buttons),
        )
        return
    service = context.args[0]
    output = _get_logs(service)
    msg = html_header(f"Logs {service}", "\U0001f4cb")
    msg += f"<pre>{html_escape(output)}</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


def _get_logs(service, lines=20):
    """Recupere les logs (Docker puis journalctl fallback)."""
    output = run_cmd(f"docker logs --tail {lines} {service} 2>&1")
    if "No such container" in output or "Error" in output:
        output = run_cmd(f"journalctl -u {service} -n {lines} --no-pager 2>/dev/null")
    return output


@authorized
async def cmd_restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Inline keyboard pour redemarrer un service."""
    if context.args:
        service = context.args[0]
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton(
                    "\U00002705 Confirmer", callback_data=f"restart_yes_{service}",
                ),
                InlineKeyboardButton(
                    "\U0000274c Annuler", callback_data="restart_no",
                ),
            ]
        ])
        msg = html_header(f"Restart {service}", "\U000026a0")
        msg += f"Confirmer le redemarrage de <b>{html_escape(service)}</b> ?"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
        return
    buttons = []
    row = []
    all_svcs = DOCKER_SERVICES + SYSTEMD_SERVICES
    for i, svc in enumerate(all_svcs):
        row.append(InlineKeyboardButton(svc, callback_data=f"restart_ask_{svc}"))
        if len(row) == 2 or i == len(all_svcs) - 1:
            buttons.append(row)
            row = []
    msg = html_header("Restart", "\U0001f504")
    msg += "<i>Quel service redemarrer ?</i>"
    await update.message.reply_text(
        msg, parse_mode=ParseMode.HTML,
        reply_markup=InlineKeyboardMarkup(buttons),
    )


# ─────────────────────────────────────────────
# Commandes monitoring
# ─────────────────────────────────────────────

@authorized
async def cmd_updates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Nombre de paquets apt a mettre a jour."""
    run_cmd("apt update -qq 2>/dev/null", timeout=60)
    raw = run_cmd("apt list --upgradable 2>/dev/null")
    lines = [ln for ln in raw.split("\n") if "/" in ln]
    msg = html_header("Mises a jour", "\U0001f4e6")
    if lines:
        msg += f"<b>{len(lines)}</b> paquet(s) a mettre a jour :\n\n<pre>"
        for line in lines[:15]:
            name = line.split("/")[0]
            msg += f"  {html_escape(name)}\n"
        if len(lines) > 15:
            msg += f"  ... et {len(lines) - 15} autres\n"
        msg += "</pre>"
    else:
        msg += "\U00002705 Systeme a jour !"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_backup(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Statut Zerobyte (logs conteneur)."""
    raw = run_cmd("docker logs --tail 30 zerobyte 2>&1")
    msg = html_header("Backup (Zerobyte)", "\U0001f4be")
    msg += f"<pre>{html_escape(raw)}</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_ssl(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Expiration certificats TLS pour les 6 domaines."""
    msg = html_header("Certificats SSL", "\U0001f512")
    for name, domain in DOMAINS.items():
        if not domain:
            continue
        raw = run_cmd(
            f"echo | openssl s_client -servername {domain} -connect {domain}:443 "
            f"2>/dev/null | openssl x509 -noout -enddate 2>/dev/null"
        )
        if "notAfter=" in raw:
            date_str = raw.split("=", 1)[1].strip()
            try:
                expiry = datetime.strptime(date_str, "%b %d %H:%M:%S %Y %Z")
                days = (expiry - datetime.utcnow()).days
                if days < 7:
                    icon = "\U0000274c"
                elif days < 30:
                    icon = "\U000026a0"
                else:
                    icon = "\U00002705"
                msg += f"{icon} <b>{html_escape(name)}</b> ({html_escape(domain)})\n"
                msg += f"   Expire dans <code>{days}j</code> ({html_escape(date_str)})\n\n"
            except ValueError:
                msg += f"\U00002753 <b>{html_escape(name)}</b>: {html_escape(raw)}\n\n"
        else:
            msg += f"\U0000274c <b>{html_escape(name)}</b> ({html_escape(domain)}): inaccessible\n\n"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_vpn(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Peers Headscale connectes."""
    raw = run_cmd("docker exec headscale headscale nodes list -o json 2>/dev/null")
    msg = html_header("VPN Headscale", "\U0001f510")
    try:
        nodes = json.loads(raw)
        if not nodes:
            msg += "<i>Aucun node enregistre</i>"
        else:
            for node in nodes:
                name = node.get("givenName", node.get("name", "?"))
                online = node.get("online", False)
                ip_list = node.get("ipAddresses", [])
                ip_str = ", ".join(ip_list[:2]) if ip_list else "?"
                last_seen = node.get("lastSeen", "?")
                icon = "\U0001f7e2" if online else "\U0001f534"
                msg += f"{icon} <b>{html_escape(str(name))}</b>\n"
                msg += f"   IP: <code>{html_escape(ip_str)}</code>\n"
                msg += f"   Vu: <code>{html_escape(str(last_seen)[:19])}</code>\n\n"
    except (json.JSONDecodeError, TypeError):
        msg += f"<pre>{html_escape(raw[:1500])}</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


@authorized
async def cmd_security(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fail2Ban status, IPs bannies, echecs SSH."""
    msg = html_header("Securite", "\U0001f6e1")
    # Fail2Ban
    f2b = run_cmd("fail2ban-client status sshd 2>/dev/null")
    if "Currently banned" in f2b:
        match = re.search(r"Currently banned:\s+(\d+)", f2b)
        banned = match.group(1) if match else "?"
        match_ip = re.search(r"Banned IP list:\s+(.*)", f2b)
        ips = match_ip.group(1).strip() if match_ip else ""
        msg += "<b>Fail2Ban sshd</b>\n"
        msg += f"  Bannies: <code>{html_escape(str(banned))}</code>\n"
        if ips:
            msg += f"  IPs: <code>{html_escape(ips[:200])}</code>\n\n"
    else:
        msg += f"<b>Fail2Ban</b>: <code>{html_escape(f2b[:200])}</code>\n\n"
    # Derniers echecs SSH
    ssh_fails = run_cmd(
        "journalctl -u sshd -n 50 --no-pager 2>/dev/null | "
        "grep -i 'failed\\|invalid' | tail -5"
    )
    msg += "<b>Derniers echecs SSH</b>\n"
    if ssh_fails.strip():
        msg += f"<pre>{html_escape(ssh_fails[:800])}</pre>\n"
    else:
        msg += "  <i>Aucun echec recent</i>\n"
    # UFW status
    ufw = run_cmd("ufw status numbered 2>/dev/null | head -20")
    msg += f"\n<b>UFW</b>\n<pre>{html_escape(ufw[:600])}</pre>"
    await update.message.reply_text(truncate(msg), parse_mode=ParseMode.HTML)


# ─────────────────────────────────────────────
# Commandes mute/unmute/ack
# ─────────────────────────────────────────────

@authorized
async def cmd_mute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Silencer les notifications pour N minutes."""
    if context.args:
        try:
            minutes = int(context.args[0])
        except ValueError:
            minutes = 30
    else:
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("15 min", callback_data="mute_15"),
                InlineKeyboardButton("30 min", callback_data="mute_30"),
                InlineKeyboardButton("60 min", callback_data="mute_60"),
                InlineKeyboardButton("120 min", callback_data="mute_120"),
            ]
        ])
        msg = html_header("Mute", "\U0001f507")
        msg += "<i>Silencer les notifications pendant combien de temps ?</i>"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
        return
    set_mute(minutes)
    msg = html_header("Mute", "\U0001f507")
    msg += f"Notifications silencees pour <b>{minutes} minutes</b>.\n"
    msg += "Utilisez /unmute pour reactiver."
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML)


@authorized
async def cmd_unmute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reactiver les notifications."""
    clear_mute()
    msg = html_header("Unmute", "\U0001f50a")
    msg += "\U00002705 Notifications reactives."
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML)


@authorized
async def cmd_ack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Acquitter une alarme specifique."""
    if not context.args:
        msg = html_header("Acquittement", "\U00002705")
        msg += "<i>Usage: /ack &lt;nom_monitor&gt;</i>\n"
        msg += "<i>Exemple: /ack headscale</i>"
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
        return
    monitor = context.args[0]
    ack_file = Path(f"/tmp/seko-ack-{monitor}.json")
    data = {
        "monitor": monitor,
        "acked_at": now_str(),
        "acked_by": str(update.effective_user.id),
    }
    ack_file.write_text(json.dumps(data))
    msg = html_header("Acquittement", "\U00002705")
    msg += f"Alarme <b>{html_escape(monitor)}</b> acquittee.\n"
    msg += "L'acquittement sera leve au prochain changement d'etat."
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML)


# ─────────────────────────────────────────────
# Uptime Kuma
# ─────────────────────────────────────────────

def _build_monitors_msg(monitors):
    """Construit le message et le clavier pour la liste des sondes."""
    msg = html_header("Uptime Kuma Monitors", "\U0001f4e1")
    buttons = []
    for m in monitors:
        mid = m.get("id", 0)
        name = m.get("name", "?")
        active = m.get("active", True)
        m_type = m.get("type", "?")
        interval = m.get("interval", 0)
        if not active:
            icon = "\U000023f8"
            status_text = "PAUSED"
            btn = InlineKeyboardButton(
                f"\U000025b6 Resume {name}", callback_data=f"ukm_resume_{mid}",
            )
        else:
            icon = "\U00002705"
            status_text = "UP"
            btn = InlineKeyboardButton(
                f"\U000023f8 Pause {name}", callback_data=f"ukm_pause_{mid}",
            )
        msg += (
            f"{icon} <b>{html_escape(str(name))}</b> [{status_text}]\n"
            f"   Type: <code>{html_escape(str(m_type))}</code> "
            f"| Interval: <code>{interval}s</code>\n\n"
        )
        buttons.append([btn])
    buttons.append([InlineKeyboardButton(
        "\U0001f519 Menu", callback_data="back_menu",
    )])
    return msg, InlineKeyboardMarkup(buttons)


@authorized
async def cmd_monitors(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Statut des sondes Uptime Kuma."""
    api, err = get_uptime_kuma_api()
    if not api:
        msg = html_header("Uptime Kuma", "\U0001f4e1")
        msg += f"\U0000274c Connexion impossible : <code>{html_escape(str(err))}</code>"
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
        return
    try:
        monitors = api.get_monitors()
        msg, keyboard = _build_monitors_msg(monitors)
        await update.message.reply_text(
            truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
    finally:
        api.disconnect()


@authorized
async def cmd_ukpause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mettre en pause une sonde Uptime Kuma."""
    api, err = get_uptime_kuma_api()
    if not api:
        msg = html_header("UK Pause", "\U000023f8")
        msg += f"\U0000274c Connexion impossible : <code>{html_escape(str(err))}</code>"
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
        return
    try:
        monitors = api.get_monitors()
        if context.args:
            target = " ".join(context.args).lower()
            found = None
            for m in monitors:
                if m.get("name", "").lower() == target:
                    found = m
                    break
            if found:
                api.pause_monitor(found["id"])
                msg = html_header("UK Pause", "\U000023f8")
                msg += f"\U000023f8 Sonde <b>{html_escape(found['name'])}</b> mise en pause."
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            else:
                msg = html_header("UK Pause", "\U000023f8")
                msg += f"Sonde <code>{html_escape(target)}</code> introuvable."
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            return
        # Sans argument : afficher les sondes actives
        active = [m for m in monitors if m.get("active", True)]
        if not active:
            msg = html_header("UK Pause", "\U000023f8")
            msg += "<i>Aucune sonde active a mettre en pause.</i>"
            await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            return
        buttons = []
        for m in active:
            buttons.append([InlineKeyboardButton(
                f"\U000023f8 {m['name']}", callback_data=f"ukpause_{m['id']}",
            )])
        msg = html_header("UK Pause", "\U000023f8")
        msg += "<i>Quelle sonde mettre en pause ?</i>"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML,
            reply_markup=InlineKeyboardMarkup(buttons),
        )
    finally:
        api.disconnect()


@authorized
async def cmd_ukresume(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reprendre une sonde Uptime Kuma en pause."""
    api, err = get_uptime_kuma_api()
    if not api:
        msg = html_header("UK Resume", "\U000025b6")
        msg += f"\U0000274c Connexion impossible : <code>{html_escape(str(err))}</code>"
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
        return
    try:
        monitors = api.get_monitors()
        if context.args:
            target = " ".join(context.args).lower()
            found = None
            for m in monitors:
                if m.get("name", "").lower() == target:
                    found = m
                    break
            if found:
                api.resume_monitor(found["id"])
                msg = html_header("UK Resume", "\U000025b6")
                msg += f"\U000025b6 Sonde <b>{html_escape(found['name'])}</b> reprise."
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            else:
                msg = html_header("UK Resume", "\U000025b6")
                msg += f"Sonde <code>{html_escape(target)}</code> introuvable."
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            return
        # Sans argument : afficher les sondes en pause
        paused = [m for m in monitors if not m.get("active", True)]
        if not paused:
            msg = html_header("UK Resume", "\U000025b6")
            msg += "<i>Aucune sonde en pause.</i>"
            await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
            return
        buttons = []
        for m in paused:
            buttons.append([InlineKeyboardButton(
                f"\U000025b6 {m['name']}", callback_data=f"ukresume_{m['id']}",
            )])
        msg = html_header("UK Resume", "\U000025b6")
        msg += "<i>Quelle sonde reprendre ?</i>"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML,
            reply_markup=InlineKeyboardMarkup(buttons),
        )
    finally:
        api.disconnect()


@authorized
async def cmd_maintenance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mode maintenance global Uptime Kuma."""
    api, err = get_uptime_kuma_api()
    if not api:
        msg = html_header("Maintenance", "\U0001f527")
        msg += f"\U0000274c Connexion impossible : <code>{html_escape(str(err))}</code>"
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
        return
    try:
        from uptime_kuma_api import MaintenanceStrategy
        if context.args:
            action = context.args[0].lower()
            if action == "on":
                monitors = api.get_monitors()
                maint = api.add_maintenance(
                    title=f"Maintenance {SERVER} (via Telegram)",
                    strategy=MaintenanceStrategy.MANUAL,
                    active=True,
                    description="Activee via le bot Telegram",
                )
                maint_id = maint.get("id") or maint.get("maintenanceID")
                if maint_id:
                    for m in monitors:
                        try:
                            api.add_monitor_maintenance(maint_id, m["id"])
                        except Exception:
                            pass
                msg = html_header("Maintenance", "\U0001f527")
                msg += (
                    "\U00002705 Mode maintenance <b>active</b> "
                    f"sur {len(monitors)} sonde(s).\n"
                    "Utilisez <code>/maintenance off</code> pour desactiver."
                )
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
                return
            if action == "off":
                maintenances = api.get_maintenances()
                deleted = 0
                for maint in maintenances:
                    try:
                        api.delete_maintenance(maint["id"])
                        deleted += 1
                    except Exception:
                        pass
                msg = html_header("Maintenance", "\U0001f527")
                msg += f"\U00002705 {deleted} maintenance(s) supprimee(s)."
                await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
                return
        # Sans argument : afficher l'etat
        maintenances = api.get_maintenances()
        msg = html_header("Maintenance", "\U0001f527")
        if not maintenances:
            msg += "<i>Aucune maintenance active.</i>\n\n"
        else:
            for maint in maintenances:
                title = maint.get("title", "?")
                active = maint.get("active", False)
                icon = "\U0001f7e0" if active else "\U000026aa"
                msg += f"{icon} <b>{html_escape(str(title))}</b>\n"
            msg += "\n"
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton(
                    "\U00002705 Activer", callback_data="maint_on",
                ),
                InlineKeyboardButton(
                    "\U0000274c Desactiver", callback_data="maint_off",
                ),
            ]
        ])
        msg += "<i>Activer ou desactiver la maintenance ?</i>"
        await update.message.reply_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
    except ImportError:
        msg = html_header("Maintenance", "\U0001f527")
        msg += "\U0000274c uptime-kuma-api non installe."
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML)
    finally:
        api.disconnect()


# ─────────────────────────────────────────────
# Navigation
# ─────────────────────────────────────────────

@authorized
async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Aide complete."""
    msg = html_header("Commandes disponibles", "\U0001f916")
    msg += (
        "<b>Navigation</b>\n"
        "  /menu \u2014 Menu principal (grille)\n"
        "  /help \u2014 Cette aide\n\n"
        "<b>Informationnelles</b>\n"
        "  /status \u2014 Resume Monit\n"
        "  /services \u2014 Liste services (interactif)\n"
        "  /containers \u2014 Conteneurs Docker\n"
        "  /disk \u2014 Usage disque\n"
        "  /memory \u2014 RAM et Swap\n"
        "  /cpu \u2014 Load average + top processus\n"
        "  /network \u2014 Ports et connexions\n"
        "  /uptime \u2014 Uptime serveur\n\n"
        "<b>Actions</b>\n"
        "  /logs [service] \u2014 Dernieres lignes de logs\n"
        "  /restart [service] \u2014 Redemarrer (avec confirmation)\n\n"
        "<b>Monitoring</b>\n"
        "  /updates \u2014 Paquets a mettre a jour\n"
        "  /backup \u2014 Statut Zerobyte\n"
        "  /ssl \u2014 Certificats TLS (expiration)\n"
        "  /vpn \u2014 Peers VPN connectes\n"
        "  /security \u2014 Fail2Ban, SSH, UFW\n\n"
        "<b>Uptime Kuma</b>\n"
        "  /monitors \u2014 Statut des sondes\n"
        "  /ukpause [sonde] \u2014 Mettre en pause\n"
        "  /ukresume [sonde] \u2014 Reprendre\n"
        "  /maintenance [on|off] \u2014 Mode maintenance\n\n"
        "<b>Notifications</b>\n"
        "  /mute [min] \u2014 Silencer les alertes\n"
        "  /unmute \u2014 Reactiver les alertes\n"
        "  /ack &lt;monitor&gt; \u2014 Acquitter une alarme\n"
    )
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML)


# ─────────────────────────────────────────────
# Callback handler centralise
# ─────────────────────────────────────────────

@authorized_callback
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Dispatche les callbacks selon leur prefixe."""
    query = update.callback_query
    await query.answer()
    data = query.data

    # --- Menu actions ---
    if data.startswith("menu_"):
        action = data.replace("menu_", "")
        dispatch = {
            "status": _cb_status,
            "containers": _cb_containers,
            "disk": _cb_disk,
            "memory": _cb_memory,
            "ssl": _cb_ssl,
            "vpn": _cb_vpn,
            "security": _cb_security,
            "monitors": _cb_monitors,
        }
        handler = dispatch.get(action)
        if handler:
            await handler(query)
        elif action == "services":
            await _cb_services(query)
        elif action == "cpu":
            await _cb_cpu(query)
        elif action == "mute":
            await _cb_mute_menu(query)
        elif action == "help":
            await _cb_help(query)
        return

    # --- Quick actions (retrocompat) ---
    if data.startswith("quick_"):
        action = data.replace("quick_", "")
        dispatch = {
            "status": _cb_status,
            "containers": _cb_containers,
            "disk": _cb_disk,
            "memory": _cb_memory,
            "ssl": _cb_ssl,
            "vpn": _cb_vpn,
            "security": _cb_security,
            "updates": _cb_updates,
        }
        handler = dispatch.get(action)
        if handler:
            await handler(query)
        return

    # --- Back to menu ---
    if data == "back_menu":
        msg = html_header("Menu principal", "\U00002261")
        msg += "<i>Cliquez sur une action :</i>"
        await query.edit_message_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD,
        )
        return

    # --- Uptime Kuma monitor pause/resume (from /monitors) ---
    if data.startswith("ukm_pause_") or data.startswith("ukm_resume_"):
        is_pause = data.startswith("ukm_pause_")
        mid = int(data.replace("ukm_pause_" if is_pause else "ukm_resume_", ""))
        api, err = get_uptime_kuma_api()
        if not api:
            msg = html_header("Uptime Kuma", "\U0001f4e1")
            msg += f"\U0000274c {html_escape(str(err))}"
            await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
            return
        try:
            if is_pause:
                api.pause_monitor(mid)
            else:
                api.resume_monitor(mid)
            monitors = api.get_monitors()
            msg, keyboard = _build_monitors_msg(monitors)
            action_text = "mise en pause" if is_pause else "reprise"
            msg = f"\U00002705 Sonde {action_text}.\n\n" + msg
            await query.edit_message_text(
                truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
            )
        finally:
            api.disconnect()
        return

    # --- Uptime Kuma pause/resume from commands ---
    if data.startswith("ukpause_"):
        mid = int(data.replace("ukpause_", ""))
        api, err = get_uptime_kuma_api()
        if not api:
            await query.edit_message_text(
                f"\U0000274c Connexion impossible : {html_escape(str(err))}",
                parse_mode=ParseMode.HTML,
            )
            return
        try:
            api.pause_monitor(mid)
            msg = html_header("UK Pause", "\U000023f8")
            msg += "\U000023f8 Sonde mise en pause."
            await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        finally:
            api.disconnect()
        return

    if data.startswith("ukresume_"):
        mid = int(data.replace("ukresume_", ""))
        api, err = get_uptime_kuma_api()
        if not api:
            await query.edit_message_text(
                f"\U0000274c Connexion impossible : {html_escape(str(err))}",
                parse_mode=ParseMode.HTML,
            )
            return
        try:
            api.resume_monitor(mid)
            msg = html_header("UK Resume", "\U000025b6")
            msg += "\U000025b6 Sonde reprise."
            await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        finally:
            api.disconnect()
        return

    # --- Maintenance toggle ---
    if data in ("maint_on", "maint_off"):
        api, err = get_uptime_kuma_api()
        if not api:
            await query.edit_message_text(
                f"\U0000274c {html_escape(str(err))}", parse_mode=ParseMode.HTML,
            )
            return
        try:
            from uptime_kuma_api import MaintenanceStrategy
            if data == "maint_on":
                monitors = api.get_monitors()
                maint = api.add_maintenance(
                    title=f"Maintenance {SERVER} (via Telegram)",
                    strategy=MaintenanceStrategy.MANUAL,
                    active=True,
                    description="Activee via le bot Telegram",
                )
                maint_id = maint.get("id") or maint.get("maintenanceID")
                if maint_id:
                    for m in monitors:
                        try:
                            api.add_monitor_maintenance(maint_id, m["id"])
                        except Exception:
                            pass
                msg = html_header("Maintenance", "\U0001f527")
                msg += f"\U00002705 Maintenance activee sur {len(monitors)} sonde(s)."
            else:
                maintenances = api.get_maintenances()
                deleted = 0
                for maint in maintenances:
                    try:
                        api.delete_maintenance(maint["id"])
                        deleted += 1
                    except Exception:
                        pass
                msg = html_header("Maintenance", "\U0001f527")
                msg += f"\U00002705 {deleted} maintenance(s) supprimee(s)."
            await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        except ImportError:
            await query.edit_message_text(
                "\U0000274c uptime-kuma-api non installe.",
                parse_mode=ParseMode.HTML,
            )
        finally:
            api.disconnect()
        return

    # --- Service details ---
    if data.startswith("svc_docker_"):
        svc = data.replace("svc_docker_", "")
        raw = run_cmd(
            f'docker inspect {svc} --format "'
            f"{{ '{{' }}.State.Status{{ '}}' }}|"
            f"{{ '{{' }}.State.StartedAt{{ '}}' }}|"
            f"{{ '{{' }}.Config.Image{{ '}}' }}"
            f'" 2>/dev/null'
        )
        msg = html_header(f"Docker: {svc}", "\U0001f433")
        parts = raw.replace('"', "").split("|")
        if len(parts) >= 3:
            status, started, image = parts[0], parts[1][:19], parts[2]
            icon = "\U00002705" if status == "running" else "\U0000274c"
            msg += f"  {icon} Status: <code>{html_escape(status)}</code>\n"
            msg += f"  Demarre: <code>{html_escape(started)}</code>\n"
            msg += f"  Image: <code>{html_escape(image)}</code>\n"
        else:
            msg += f"<pre>{html_escape(raw)}</pre>"
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("\U0001f4cb Logs", callback_data=f"logs_{svc}"),
                InlineKeyboardButton("\U0001f504 Restart", callback_data=f"restart_ask_{svc}"),
            ]
        ])
        await query.edit_message_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
        return

    if data.startswith("svc_systemd_"):
        svc = data.replace("svc_systemd_", "")
        raw = run_cmd(f"systemctl status {svc} --no-pager -l 2>/dev/null | head -10")
        msg = html_header(f"Systemd: {svc}", "\U00002699\U0000fe0f")
        msg += f"<pre>{html_escape(raw)}</pre>"
        await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        return

    # --- Logs callback ---
    if data.startswith("logs_"):
        svc = data.replace("logs_", "")
        output = _get_logs(svc)
        msg = html_header(f"Logs {svc}", "\U0001f4cb")
        msg += f"<pre>{html_escape(output)}</pre>"
        await query.edit_message_text(truncate(msg), parse_mode=ParseMode.HTML)
        return

    # --- Restart flow ---
    if data.startswith("restart_ask_"):
        svc = data.replace("restart_ask_", "")
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton(
                    "\U00002705 Confirmer", callback_data=f"restart_yes_{svc}",
                ),
                InlineKeyboardButton(
                    "\U0000274c Annuler", callback_data="restart_no",
                ),
            ]
        ])
        msg = html_header(f"Restart {svc}", "\U000026a0")
        msg += f"Confirmer le redemarrage de <b>{html_escape(svc)}</b> ?"
        await query.edit_message_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
        return

    if data.startswith("restart_yes_"):
        svc = data.replace("restart_yes_", "")
        msg = html_header(f"Restart {svc}", "\U0001f504")
        msg += f"Redemarrage de <b>{html_escape(svc)}</b> en cours...\n\n"
        output = run_cmd(f"docker restart {svc} 2>/dev/null")
        if "No such container" in output or "Error" in output:
            output = run_cmd(
                f"systemctl restart {svc} 2>/dev/null && echo 'OK' || echo 'ERREUR'"
            )
        msg += f"Resultat: <code>{html_escape(output[:500])}</code>"
        await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        return

    if data == "restart_no":
        msg = html_header("Restart", "\U0000274c")
        msg += "Redemarrage annule."
        await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        return

    # --- Mute callbacks ---
    if data == "mute_unmute":
        clear_mute()
        msg = html_header("Unmute", "\U0001f50a")
        msg += "\U00002705 Notifications reactives."
        await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        return

    if data.startswith("mute_"):
        try:
            minutes = int(data.replace("mute_", ""))
        except ValueError:
            minutes = 30
        set_mute(minutes)
        msg = html_header("Mute", "\U0001f507")
        msg += f"Notifications silencees pour <b>{minutes} minutes</b>.\n"
        msg += "Utilisez /unmute pour reactiver."
        await query.edit_message_text(msg, parse_mode=ParseMode.HTML)
        return


# --- Callback helpers ---


async def _cb_status(query):
    """Callback: Monit status."""
    raw = run_cmd("monit summary 2>/dev/null || echo 'Monit indisponible'")
    msg = html_header("Monit Status", "\U0001f4ca")
    for line in raw.split("\n"):
        if not line.strip():
            continue
        if "OK" in line or "Running" in line or "Accessible" in line:
            msg += f"\U00002705 <code>{html_escape(line.strip())}</code>\n"
        elif "FAILED" in line or "Does not exist" in line:
            msg += f"\U0000274c <code>{html_escape(line.strip())}</code>\n"
        else:
            msg += f"  <code>{html_escape(line.strip())}</code>\n"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_containers(query):
    """Callback: Docker containers."""
    raw = run_cmd(
        'docker ps -a --format "'
        "{{ '{{' }}.Names{{ '}}' }}|"
        "{{ '{{' }}.Status{{ '}}' }}"
        '"'
    )
    msg = html_header("Conteneurs", "\U0001f433")
    for line in raw.split("\n"):
        if "|" not in line:
            continue
        name, status = line.split("|", 1)
        icon = "\U00002705" if "Up" in status else "\U0000274c"
        msg += (
            f"{icon} <b>{html_escape(name.strip())}</b>: "
            f"<code>{html_escape(status.strip())}</code>\n"
        )
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_disk(query):
    """Callback: Disk usage."""
    raw = run_cmd("df -h --output=target,pcent -x tmpfs -x devtmpfs 2>/dev/null")
    msg = html_header("Disque", "\U0001f4be")
    for line in raw.split("\n")[1:]:
        parts = line.split()
        if len(parts) < 2:
            continue
        try:
            pct = int(parts[1].replace("%", ""))
        except ValueError:
            continue
        msg += f"<b>{html_escape(parts[0])}</b>  {progress_bar(pct)}\n"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_memory(query):
    """Callback: Memory usage."""
    raw = run_cmd("free -m | grep Mem")
    msg = html_header("Memoire", "\U0001f9e0")
    parts = raw.split()
    if len(parts) >= 3:
        try:
            total, used = int(parts[1]), int(parts[2])
            pct = (used / total * 100) if total > 0 else 0
            msg += f"RAM: {progress_bar(pct)}  <code>{used}/{total} Mo</code>\n"
        except (ValueError, IndexError):
            msg += f"<pre>{html_escape(raw)}</pre>"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_cpu(query):
    """Callback: CPU info."""
    loadavg = run_cmd("cat /proc/loadavg")
    nproc = run_cmd("nproc")
    msg = html_header("CPU", "\U00002699\U0000fe0f")
    parts = loadavg.split()
    if len(parts) >= 3:
        msg += f"Load: <code>{parts[0]} {parts[1]} {parts[2]}</code>\n"
        msg += f"Coeurs: <code>{html_escape(nproc.strip())}</code>\n"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_ssl(query):
    """Callback: SSL certificates."""
    msg = html_header("SSL", "\U0001f512")
    for name, domain in DOMAINS.items():
        if not domain:
            continue
        raw = run_cmd(
            f"echo | openssl s_client -servername {domain} -connect {domain}:443 "
            f"2>/dev/null | openssl x509 -noout -enddate 2>/dev/null"
        )
        if "notAfter=" in raw:
            date_str = raw.split("=", 1)[1].strip()
            try:
                expiry = datetime.strptime(date_str, "%b %d %H:%M:%S %Y %Z")
                days = (expiry - datetime.utcnow()).days
                if days < 7:
                    icon = "\U0000274c"
                elif days < 30:
                    icon = "\U000026a0"
                else:
                    icon = "\U00002705"
                msg += f"{icon} <b>{html_escape(name)}</b>: {days}j\n"
            except ValueError:
                msg += f"\U00002753 {html_escape(name)}\n"
        else:
            msg += f"\U0000274c {html_escape(name)}\n"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_vpn(query):
    """Callback: VPN peers."""
    raw = run_cmd("docker exec headscale headscale nodes list -o json 2>/dev/null")
    msg = html_header("VPN", "\U0001f510")
    try:
        nodes = json.loads(raw)
        for node in nodes:
            name = node.get("givenName", node.get("name", "?"))
            online = node.get("online", False)
            icon = "\U0001f7e2" if online else "\U0001f534"
            msg += f"{icon} <b>{html_escape(str(name))}</b>\n"
    except (json.JSONDecodeError, TypeError):
        msg += "<i>Erreur de lecture</i>"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_security(query):
    """Callback: Security overview."""
    f2b = run_cmd("fail2ban-client status sshd 2>/dev/null")
    msg = html_header("Securite", "\U0001f6e1")
    match = re.search(r"Currently banned:\s+(\d+)", f2b)
    banned = match.group(1) if match else "?"
    msg += f"Fail2Ban: <code>{html_escape(str(banned))}</code> IP(s) bannies\n"
    ufw = run_cmd("ufw status 2>/dev/null | head -5")
    msg += f"\n<pre>{html_escape(ufw)}</pre>"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_updates(query):
    """Callback: Available updates."""
    raw = run_cmd("apt list --upgradable 2>/dev/null")
    lines = [ln for ln in raw.split("\n") if "/" in ln]
    msg = html_header("Updates", "\U0001f4e6")
    msg += f"<b>{len(lines)}</b> paquet(s) a mettre a jour"
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(msg, parse_mode=ParseMode.HTML, reply_markup=keyboard)


async def _cb_monitors(query):
    """Callback: Uptime Kuma monitors."""
    api, err = get_uptime_kuma_api()
    if not api:
        msg = html_header("Uptime Kuma", "\U0001f4e1")
        msg += f"\U0000274c {html_escape(str(err))}"
        keyboard = InlineKeyboardMarkup([[
            InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
        ]])
        await query.edit_message_text(
            msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
        return
    try:
        monitors = api.get_monitors()
        msg, keyboard = _build_monitors_msg(monitors)
        await query.edit_message_text(
            truncate(msg), parse_mode=ParseMode.HTML, reply_markup=keyboard,
        )
    finally:
        api.disconnect()


async def _cb_services(query):
    """Callback: Services list."""
    buttons = []
    for svc in DOCKER_SERVICES:
        buttons.append([InlineKeyboardButton(
            f"\U0001f433 {svc}", callback_data=f"svc_docker_{svc}",
        )])
    for svc in SYSTEMD_SERVICES:
        buttons.append([InlineKeyboardButton(
            f"\U00002699\U0000fe0f {svc}", callback_data=f"svc_systemd_{svc}",
        )])
    buttons.append([InlineKeyboardButton(
        "\U0001f519 Menu", callback_data="back_menu",
    )])
    msg = html_header("Services", "\U0001f5a5")
    msg += "<i>Cliquez sur un service</i>"
    await query.edit_message_text(
        msg, parse_mode=ParseMode.HTML, reply_markup=InlineKeyboardMarkup(buttons),
    )


async def _cb_mute_menu(query):
    """Callback: Mute menu."""
    muted, mute_info = is_muted()
    msg = html_header("Mute", "\U0001f507")
    if muted:
        msg += f"\U0001f507 Notifications silencees ({mute_info})\n\n"
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("\U0001f50a Unmute", callback_data="mute_unmute")],
            [InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu")],
        ])
    else:
        msg += "\U0001f50a Notifications actives.\n\n"
        msg += "<i>Silencer pendant :</i>"
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("15 min", callback_data="mute_15"),
                InlineKeyboardButton("30 min", callback_data="mute_30"),
                InlineKeyboardButton("60 min", callback_data="mute_60"),
                InlineKeyboardButton("120 min", callback_data="mute_120"),
            ],
            [InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu")],
        ])
    await query.edit_message_text(
        msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


async def _cb_help(query):
    """Callback: Help text."""
    msg = html_header("Commandes", "\U0001f916")
    msg += (
        "/menu \u2014 Menu principal\n"
        "/monitors \u2014 Sondes Uptime Kuma\n"
        "/status \u2014 Monit\n"
        "/services \u2014 Services\n"
        "/containers \u2014 Docker\n"
        "/disk /memory /cpu \u2014 Ressources\n"
        "/ssl /vpn /security \u2014 Securite\n"
        "/logs /restart \u2014 Actions\n"
        "/mute /unmute /ack \u2014 Alertes\n"
        "/ukpause /ukresume \u2014 Sondes\n"
        "/maintenance \u2014 Maintenance\n"
        "/help \u2014 Aide complete\n"
    )
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("\U0001f519 Menu", callback_data="back_menu"),
    ]])
    await query.edit_message_text(
        msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
    )


# ─────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────

def main():
    """Point d'entree du bot."""
    if not TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN non defini !")
        return
    if not ALLOWED_IDS:
        logger.error("ALLOWED_CHAT_IDS non defini !")
        return

    app = Application.builder().token(TOKEN).build()

    # Menu & navigation
    app.add_handler(CommandHandler("menu", cmd_menu))
    app.add_handler(CommandHandler("start", cmd_menu))
    app.add_handler(CommandHandler("quick", cmd_menu))

    # Commandes informationnelles
    app.add_handler(CommandHandler("status", cmd_status))
    app.add_handler(CommandHandler("services", cmd_services))
    app.add_handler(CommandHandler("containers", cmd_containers))
    app.add_handler(CommandHandler("disk", cmd_disk))
    app.add_handler(CommandHandler("memory", cmd_memory))
    app.add_handler(CommandHandler("cpu", cmd_cpu))
    app.add_handler(CommandHandler("network", cmd_network))
    app.add_handler(CommandHandler("uptime", cmd_uptime))

    # Commandes actions
    app.add_handler(CommandHandler("logs", cmd_logs))
    app.add_handler(CommandHandler("restart", cmd_restart))

    # Commandes monitoring
    app.add_handler(CommandHandler("updates", cmd_updates))
    app.add_handler(CommandHandler("backup", cmd_backup))
    app.add_handler(CommandHandler("ssl", cmd_ssl))
    app.add_handler(CommandHandler("vpn", cmd_vpn))
    app.add_handler(CommandHandler("security", cmd_security))

    # Commandes notifications
    app.add_handler(CommandHandler("mute", cmd_mute))
    app.add_handler(CommandHandler("unmute", cmd_unmute))
    app.add_handler(CommandHandler("ack", cmd_ack))

    # Uptime Kuma
    app.add_handler(CommandHandler("monitors", cmd_monitors))
    app.add_handler(CommandHandler("ukpause", cmd_ukpause))
    app.add_handler(CommandHandler("ukresume", cmd_ukresume))
    app.add_handler(CommandHandler("maintenance", cmd_maintenance))

    # Navigation
    app.add_handler(CommandHandler("help", cmd_help))

    # Callback handler centralise
    app.add_handler(CallbackQueryHandler(handle_callback))

    logger.info("Bot demarre pour le serveur [%s]", SERVER)
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
